
==========
File: .\Program.cs
==========

using GraphCalc.Infrastructure.Facade;
using GraphCalc.Infrastructure.Persistence;
using GraphCalc.Infrastructure.Repositories;
using GraphCalc.Domain.Interfaces;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

builder.Services.AddScoped<GraphCalculationFacade>();
builder.Services.AddSingleton<IGraphRepository, InMemoryGraphRepository>();
builder.Services.AddSingleton<IUserRepository, InMemoryUserRepository>();
builder.Services.AddSingleton<InMemoryPublishedGraphRepository>();
builder.Services.AddSingleton<InMemoryGraphSetRepository>();

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.MapControllers();

app.Run();

==========
File: .\Api\Controllers\GraphCalculationController.cs
==========

using Microsoft.AspNetCore.Mvc;
using GraphCalc.Api.Dtos;
using GraphCalc.Api.Mappers;
using GraphCalc.Infrastructure.Facade;
using GraphCalc.Infrastructure.Repositories;
using GraphCalc.Domain.Interfaces;
using GraphCalc.Domain.Entities;

namespace GraphCalc.Api.Controllers;

[ApiController]
[Route("api/graphcalculation")]
public class GraphCalculationController : ControllerBase
{
    private readonly GraphCalculationFacade calculationFacade;
    private readonly IGraphRepository graphRepository;
    private readonly IUserRepository userRepository;
    private readonly InMemoryPublishedGraphRepository publishedGraphRepository;
    private readonly InMemoryGraphSetRepository graphSetRepository;

    public GraphCalculationController(
        GraphCalculationFacade calculationFacade,
        IGraphRepository graphRepository,
        IUserRepository userRepository,
        InMemoryPublishedGraphRepository publishedGraphRepository,
        InMemoryGraphSetRepository graphSetRepository)
    {
        this.calculationFacade = calculationFacade;
        this.graphRepository = graphRepository;
        this.userRepository = userRepository;
        this.publishedGraphRepository = publishedGraphRepository;
        this.graphSetRepository = graphSetRepository;
    }

    [HttpPost("calculate")]
    [ProducesResponseType(typeof(GraphResponse), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    public IActionResult Calculate([FromBody] GraphCalculationRequest request)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(request.Expression))
                return BadRequest("Expression cannot be empty");

            if (request.XMin >= request.XMax)
                return BadRequest("XMin must be less than XMax");

            if (request.XStep <= 0)
                return BadRequest("XStep must be greater than 0");

            var graph = request.AutoYRange
                ? calculationFacade.GetGraphWithAutoYRange(
                    request.Expression,
                    request.XMin,
                    request.XMax,
                    request.XStep)
                : calculationFacade.GetGraph(
                    request.Expression,
                    request.XMin,
                    request.XMax,
                    request.XStep);

            var response = GraphToResponseMapper.Map(graph);
            return Ok(response);
        }
        catch (Exception ex)
        {
            return BadRequest($"Error calculating graph: {ex.Message}");
        }
    }

    [HttpPost("calculate-and-save")]
    [ProducesResponseType(typeof(GraphResponse), StatusCodes.Status201Created)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    public IActionResult CalculateAndSave([FromBody] GraphCalculationRequest request)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(request.Expression))
                return BadRequest("Expression cannot be empty");

            if (request.XMin >= request.XMax)
                return BadRequest("XMin must be less than XMax");

            if (request.XStep <= 0)
                return BadRequest("XStep must be greater than 0");

            var graph = request.AutoYRange
                ? calculationFacade.GetGraphWithAutoYRange(
                    request.Expression,
                    request.XMin,
                    request.XMax,
                    request.XStep)
                : calculationFacade.GetGraph(
                    request.Expression,
                    request.XMin,
                    request.XMax,
                    request.XStep);

            graphRepository.Add(graph);

            var response = GraphToResponseMapper.Map(graph);
            return CreatedAtAction(nameof(GetGraphById), new { id = graph.Id }, response);
        }
        catch (Exception ex)
        {
            return BadRequest($"Error calculating and saving graph: {ex.Message}");
        }
    }

    [HttpGet("{id}")]
    [ProducesResponseType(typeof(GraphResponse), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public IActionResult GetGraphById(Guid id)
    {
        var graph = graphRepository.GetById(id);
        if (graph == null)
            return NotFound($"Graph with ID {id} not found");

        var response = GraphToResponseMapper.Map(graph);
        return Ok(response);
    }

    [HttpGet]
    [ProducesResponseType(typeof(List<GraphResponse>), StatusCodes.Status200OK)]
    public IActionResult GetAllGraphs()
    {
        var graphs = graphRepository.GetAll();
        var responses = graphs.Select(GraphToResponseMapper.Map).ToList();
        return Ok(responses);
    }

    [HttpGet("search")]
    [ProducesResponseType(typeof(List<GraphResponse>), StatusCodes.Status200OK)]
    public IActionResult SearchByExpression([FromQuery] string expressionText)
    {
        if (string.IsNullOrWhiteSpace(expressionText))
            return BadRequest("Expression text cannot be empty");

        var graphs = graphRepository.GetByExpressionText(expressionText);
        var responses = graphs.Select(GraphToResponseMapper.Map).ToList();
        return Ok(responses);
    }

    [HttpDelete("{id}")]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public IActionResult DeleteGraph(Guid id)
    {
        var success = graphRepository.Delete(id);
        if (!success)
            return NotFound($"Graph with ID {id} not found");

        return NoContent();
    }

    [HttpPost("save")]
    [ProducesResponseType(typeof(GraphResponse), StatusCodes.Status201Created)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public IActionResult SaveGraph([FromBody] SaveGraphRequest request)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(request.Expression))
                return BadRequest("Expression cannot be empty");

            if (request.XMin >= request.XMax)
                return BadRequest("XMin must be less than XMax");

            if (request.XStep <= 0)
                return BadRequest("XStep must be greater than 0");

            if (string.IsNullOrWhiteSpace(request.Title))
                return BadRequest("Title cannot be empty");

            var user = userRepository.GetById(request.UserId);
            if (user == null)
                return NotFound($"User with ID {request.UserId} not found");

            var graph = request.AutoYRange
                ? calculationFacade.GetGraphWithAutoYRange(
                    request.Expression,
                    request.XMin,
                    request.XMax,
                    request.XStep)
                : calculationFacade.GetGraph(
                    request.Expression,
                    request.XMin,
                    request.XMax,
                    request.XStep);

            graphRepository.Add(graph);

            var publishedGraph = PublishedGraph.Create(
                request.UserId,
                graph.Id,
                request.Title,
                request.Description);

            publishedGraphRepository.Add(publishedGraph);
            user.PublishGraph(graph.Id);

            var response = GraphToResponseMapper.Map(graph);
            return CreatedAtAction(nameof(GetGraphById), new { id = graph.Id }, response);
        }
        catch (Exception ex)
        {
            return BadRequest($"Error saving graph: {ex.Message}");
        }
    }

    [HttpPost("saveset")]
    [ProducesResponseType(typeof(UserGraphSetDto), StatusCodes.Status201Created)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public IActionResult SaveGraphSet([FromBody] SaveGraphSetRequest request)
    {
        try
        {
            if (request.Graphs == null || request.Graphs.Count == 0)
                return BadRequest("GraphSet must contain at least one graph");

            if (string.IsNullOrWhiteSpace(request.Title))
                return BadRequest("Title cannot be empty");

            var user = userRepository.GetById(request.UserId);
            if (user == null)
                return NotFound($"User with ID {request.UserId} not found");

            var graphSet = GraphSet.Create();
            var graphDtos = new List<UserGraphDto>();

            foreach (var graphRequest in request.Graphs)
            {
                if (string.IsNullOrWhiteSpace(graphRequest.Expression))
                    return BadRequest("All graphs must have an expression");

                if (graphRequest.XMin >= graphRequest.XMax || graphRequest.XStep <= 0)
                    return BadRequest("Invalid range or step for graph");

                var graph = graphRequest.AutoYRange
                    ? calculationFacade.GetGraphWithAutoYRange(
                        graphRequest.Expression,
                        graphRequest.XMin,
                        graphRequest.XMax,
                        graphRequest.XStep)
                    : calculationFacade.GetGraph(
                        graphRequest.Expression,
                        graphRequest.XMin,
                        graphRequest.XMax,
                        graphRequest.XStep);

                graphRepository.Add(graph);
                graphSet.AddGraph(graph);

                var publishedGraph = PublishedGraph.Create(
                    request.UserId,
                    graph.Id,
                    graphRequest.Title ?? $"Graph {graphDtos.Count + 1}",
                    graphRequest.Description);

                publishedGraphRepository.Add(publishedGraph);
                user.PublishGraph(graph.Id);

                graphDtos.Add(new UserGraphDto(
                    Id: graph.Id,
                    Expression: graph.Expression.Text,
                    Title: graphRequest.Title ?? $"Graph {graphDtos.Count}",
                    Description: graphRequest.Description
                ));
            }

            graphSetRepository.Add(graphSet);

            var response = new UserGraphSetDto(
                Id: graphSet.Id,
                Title: request.Title,
                Description: request.Description,
                Graphs: graphDtos
            );

            return CreatedAtAction(nameof(GetGraphById), new { id = graphSet.Id }, response);
        }
        catch (Exception ex)
        {
            return BadRequest($"Error saving graph set: {ex.Message}");
        }
    }

    [HttpGet("user/{userId}/graphs")]
    [ProducesResponseType(typeof(UserGraphsListResponse), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public IActionResult GetUserGraphs(Guid userId)
    {
        var user = userRepository.GetById(userId);
        if (user == null)
            return NotFound($"User with ID {userId} not found");

        var publishedGraphs = publishedGraphRepository.GetByUserId(userId);
        var graphDtos = new List<UserGraphDto>();

        foreach (var publishedGraph in publishedGraphs)
        {
            var graph = graphRepository.GetById(publishedGraph.GraphId);
            if (graph != null)
            {
                graphDtos.Add(new UserGraphDto(
                    Id: graph.Id,
                    Expression: graph.Expression.Text,
                    Title: publishedGraph.Metadata.Title,
                    Description: publishedGraph.Metadata.Description
                ));
            }
        }

        var graphSets = graphSetRepository.GetAll()
            .Where(gs => gs.Graphs.Any(g => publishedGraphRepository
                .GetByGraphId(g.Id)
                .Any(pg => pg.UserId == userId)))
            .ToList();

        var graphSetDtos = new List<UserGraphSetDto>();
        foreach (var graphSet in graphSets)
        {
            var setGraphDtos = new List<UserGraphDto>();
            foreach (var graph in graphSet.Graphs)
            {
                var published = publishedGraphRepository.GetByGraphId(graph.Id)
                    .FirstOrDefault(pg => pg.UserId == userId);

                if (published != null)
                {
                    setGraphDtos.Add(new UserGraphDto(
                        Id: graph.Id,
                        Expression: graph.Expression.Text,
                        Title: published.Metadata.Title,
                        Description: published.Metadata.Description
                    ));
                }
            }

            if (setGraphDtos.Count > 0)
            {
                graphSetDtos.Add(new UserGraphSetDto(
                    Id: graphSet.Id,
                    Title: $"GraphSet {graphSetDtos.Count + 1}",
                    Description: null,
                    Graphs: setGraphDtos
                ));
            }
        }

        var response = new UserGraphsListResponse(
            UserId: userId,
            Graphs: graphDtos,
            GraphSets: graphSetDtos
        );

        return Ok(response);
    }
}



==========
File: .\Api\Controllers\UserController.cs
==========

using Microsoft.AspNetCore.Mvc;
using GraphCalc.Api.Dtos;
using GraphCalc.Infrastructure.Repositories;
using GraphCalc.Domain.Interfaces;
using DomainUser = GraphCalc.Domain.Entities.User;

namespace GraphCalc.Api.Controllers;

[ApiController]
[Route("api/user")]
public class UserController : ControllerBase
{
    private readonly IUserRepository userRepository;
    private readonly IGraphRepository graphRepository;
    private readonly InMemoryPublishedGraphRepository publishedGraphRepository;
    private readonly InMemoryGraphSetRepository graphSetRepository;

    public UserController(
        IUserRepository userRepository,
        IGraphRepository graphRepository,
        InMemoryPublishedGraphRepository publishedGraphRepository,
        InMemoryGraphSetRepository graphSetRepository)
    {
        this.userRepository = userRepository;
        this.graphRepository = graphRepository;
        this.publishedGraphRepository = publishedGraphRepository;
        this.graphSetRepository = graphSetRepository;
    }

    [HttpPost("register")]
    [ProducesResponseType(typeof(UserGraphsListResponse), StatusCodes.Status201Created)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    public IActionResult RegisterUser([FromBody] CreateUserRequest request)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(request.Username))
                return BadRequest("Username cannot be empty");

            if (string.IsNullOrWhiteSpace(request.Email))
                return BadRequest("Email cannot be empty");

            var existingByEmail = userRepository.GetByEmail(request.Email);
            if (existingByEmail != null)
                return BadRequest("Email already registered");

            var existingByUsername = userRepository.GetByUsername(request.Username);
            if (existingByUsername != null)
                return BadRequest("Username already taken");

            var user = DomainUser.Create(request.Username, request.Email, request.Description);
            userRepository.Add(user);

            var response = new UserGraphsListResponse(
                UserId: user.Id,
                Graphs: new(),
                GraphSets: new()
            );

            return CreatedAtAction(nameof(GetUserGraphs), new { userId = user.Id }, response);
        }
        catch (Exception ex)
        {
            return BadRequest($"Error registering user: {ex.Message}");
        }
    }

    [HttpGet("{userId}/graphs")]
    [ProducesResponseType(typeof(UserGraphsListResponse), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public IActionResult GetUserGraphs(Guid userId)
    {
        var user = userRepository.GetById(userId);
        if (user == null)
            return NotFound($"User with ID {userId} not found");

        var publishedGraphs = publishedGraphRepository.GetByUserId(userId);
        var graphDtos = new List<UserGraphDto>();

        foreach (var publishedGraph in publishedGraphs)
        {
            var graph = graphRepository.GetById(publishedGraph.GraphId);
            if (graph != null)
            {
                graphDtos.Add(new UserGraphDto(
                    Id: graph.Id,
                    Expression: graph.Expression.Text,
                    Title: publishedGraph.Metadata.Title,
                    Description: publishedGraph.Metadata.Description
                ));
            }
        }

        var graphSets = graphSetRepository.GetAll()
            .Where(gs => gs.Graphs.Any(g => publishedGraphRepository
                .GetByGraphId(g.Id)
                .Any(pg => pg.UserId == userId)))
            .ToList();

        var graphSetDtos = new List<UserGraphSetDto>();
        foreach (var graphSet in graphSets)
        {
            var setGraphDtos = new List<UserGraphDto>();
            foreach (var graph in graphSet.Graphs)
            {
                var published = publishedGraphRepository.GetByGraphId(graph.Id)
                    .FirstOrDefault(pg => pg.UserId == userId);

                if (published != null)
                {
                    setGraphDtos.Add(new UserGraphDto(
                        Id: graph.Id,
                        Expression: graph.Expression.Text,
                        Title: published.Metadata.Title,
                        Description: published.Metadata.Description
                    ));
                }
            }

            if (setGraphDtos.Count > 0)
            {
                graphSetDtos.Add(new UserGraphSetDto(
                    Id: graphSet.Id,
                    Title: $"GraphSet {graphSetDtos.Count + 1}",
                    Description: null,
                    Graphs: setGraphDtos
                ));
            }
        }

        var response = new UserGraphsListResponse(
            UserId: userId,
            Graphs: graphDtos,
            GraphSets: graphSetDtos
        );

        return Ok(response);
    }

    [HttpGet("{userId}")]
    [ProducesResponseType(typeof(UserProfileResponse), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public IActionResult GetUser(Guid userId)
    {
        var user = userRepository.GetById(userId);
        if (user == null)
            return NotFound($"User with ID {userId} not found");

        var response = new UserProfileResponse(
            Id: user.Id,
            Username: user.Username,
            Email: user.Email,
            Description: user.Description,
            PublishedGraphCount: user.PublishedGraphIds.Count
        );

        return Ok(response);
    }

    [HttpPut("{userId}/description")]
    [ProducesResponseType(StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public IActionResult UpdateUserDescription(Guid userId, [FromBody] UpdateDescriptionRequest request)
    {
        var user = userRepository.GetById(userId);
        if (user == null)
            return NotFound($"User with ID {userId} not found");

        user.UpdateDescription(request.Description);
        return Ok(new { message = "Description updated successfully" });
    }
}


==========
File: .\Api\Dtos\CreateUserRequest.cs
==========

namespace GraphCalc.Api.Dtos;

public record CreateUserRequest(
    string Username = "",
    string Email = "",
    string? Description = null);

==========
File: .\Api\Dtos\GraphCalculationRequest.cs
==========

namespace GraphCalc.Api.Dtos;

public record GraphCalculationRequest(
    string Expression = "",
    double XMin = 0,
    double XMax = 0,
    double XStep = 0,
    bool AutoYRange = false);


==========
File: .\Api\Dtos\GraphResponse.cs
==========

using GraphCalc.Domain.ValueObjects;

namespace GraphCalc.Api.Dtos;

public record GraphResponse(
    Guid Id,
    string Expression,
    string IndependentVariable,
    List<MathPoint> Points,
    NumericRange? Range);


==========
File: .\Api\Dtos\SaveGraphRequest.cs
==========

namespace GraphCalc.Api.Dtos;

public record SaveGraphRequest(
    string Expression = "",
    double XMin = 0,
    double XMax = 0,
    double XStep = 0,
    bool AutoYRange = false,
    Guid UserId = default,
    string Title = "",
    string? Description = null);


==========
File: .\Api\Dtos\SaveGraphSetRequest.cs
==========

namespace GraphCalc.Api.Dtos;

public record SaveGraphSetRequest(
    List<SaveGraphRequest> Graphs,
    Guid UserId,
    string Title = "",
    string? Description = null);

==========
File: .\Api\Dtos\UpdateDescriptionRequest.cs
==========

namespace GraphCalc.Api.Dtos;

public record UpdateDescriptionRequest(
    string? Description = null);

==========
File: .\Api\Dtos\UserGraphDto.cs
==========

namespace GraphCalc.Api.Dtos;

public record UserGraphDto(
    Guid Id,
    string Expression,
    string Title,
    string? Description = null);

==========
File: .\Api\Dtos\UserGraphSetDto.cs
==========

namespace GraphCalc.Api.Dtos;

public record UserGraphSetDto(
    Guid Id,
    string Title,
    string? Description = null,
    List<UserGraphDto>? Graphs = null);

==========
File: .\Api\Dtos\UserGraphsListResponse.cs
==========

namespace GraphCalc.Api.Dtos;

public record UserGraphsListResponse(
    Guid UserId,
    List<UserGraphDto>? Graphs = null,
    List<UserGraphSetDto>? GraphSets = null);

==========
File: .\Api\Dtos\UserProfileResponse.cs
==========

namespace GraphCalc.Api.Dtos;

public record UserProfileResponse(
    Guid Id,
    string Username,
    string Email,
    string? Description = null,
    int PublishedGraphCount = 0);

==========
File: .\Api\Mappers\GraphToResponseMapper.cs
==========

using GraphCalc.Api.Dtos;
using GraphCalc.Domain.Entities;
using GraphCalc.Domain.ValueObjects;

namespace GraphCalc.Api.Mappers;

public class GraphToResponseMapper
{
    public static GraphResponse Map(Graph graph)
    {
        return new GraphResponse(
            Id: graph.Id,
            Expression: graph.Expression.Text,
            IndependentVariable: graph.IndependentVariable,
            Points: graph.Points.ToList(),
            Range: graph.Range
        );
    }
}


==========
File: .\Domain\Common\Entity.cs
==========

namespace GraphCalc.Domain.Common;

public abstract class Entity
{
    public Guid Id { get; protected set; }

    protected Entity()
    {
        Id = Guid.NewGuid();
    }

    protected Entity(Guid id)
    {
        Id = id;
    }

    public override bool Equals(object? obj)
    {
        if (ReferenceEquals(this, obj))
            return true;

        if (obj is null || obj is not Entity other)
            return false;

        return Id == other.Id;
    }

    public override int GetHashCode() => Id.GetHashCode();
    public static bool operator ==(Entity? a, Entity? b) => Equals(a, b);
    public static bool operator !=(Entity? a, Entity? b) => !Equals(a, b);
}


==========
File: .\Domain\Common\ValueObject.cs
==========

namespace GraphCalc.Domain.Common;

public abstract record ValueObject;

==========
File: .\Domain\Entities\Graph.cs
==========

using GraphCalc.Domain.Common;
using GraphCalc.Domain.ValueObjects;

namespace GraphCalc.Domain.Entities;

public class Graph : Entity
{
    private readonly List<MathPoint> points = new();

    private Graph(Guid id, MathExpression expression, string independentVariable)
        : base(id)
    {
        Expression = expression;
        IndependentVariable = independentVariable;
    }

    public MathExpression Expression { get; private set; }
    public string IndependentVariable { get; private init; }
    public NumericRange? Range { get; private set; }
    public IReadOnlyList<MathPoint> Points => points.AsReadOnly();

    public static Graph Create(
        MathExpression expression,
        string independentVariable)
         => new Graph(
                Guid.NewGuid(),
                expression,
                independentVariable);

    public Graph WithRange(NumericRange range)
    {
        Range = range;
        return this;
    }

    public Graph SetPoints(IEnumerable<MathPoint> points)
    {
        this.points.Clear();
        this.points.AddRange(points);
        return this;
    }

    public Graph ClearPoints()
    {
        points.Clear();
        return this;
    }

    public Graph WithExpression(MathExpression newExpression)
    {
        Expression = newExpression;
        points.Clear();
        return this;
    }
}

==========
File: .\Domain\Entities\GraphSet.cs
==========

using GraphCalc.Domain.Common;
using GraphCalc.Domain.ValueObjects;

namespace GraphCalc.Domain.Entities;

public class GraphSet : Entity
{
    private readonly List<Graph> graphs = new();

    private GraphSet(Guid id) : base(id) { }

    public IReadOnlyList<Graph> Graphs => graphs.AsReadOnly();
    public NumericRange? Range { get; private set; }

    public static GraphSet Create() => new(Guid.NewGuid());

    public GraphSet WithRange(NumericRange range)
    {
        Range = range;
        return this;
    }

    public GraphSet AddGraph(Graph graph)
    {
        if (graphs.Any(g => g.Id == graph.Id))
            return this;

        graphs.Add(graph);
        if (Range != null)
            graph.WithRange(Range);

        return this;
    }

    public GraphSet RemoveGraph(Guid graphId)
    {
        graphs.RemoveAll(g => g.Id == graphId);
        return this;
    }

    public GraphSet ApplyRange()
    {
        if (Range == null)
            return this;

        foreach (var graph in graphs)
            graph.WithRange(Range);

        return this;
    }
}

==========
File: .\Domain\Entities\MathExpression.cs
==========

using GraphCalc.Domain.Common;

namespace GraphCalc.Domain.Entities;

public class MathExpression : Entity
{
    private readonly List<Variable> variables = new();

    private MathExpression(Guid id, string text, string? name = null)
        : base(id)
    {
        Text = text;
        Name = name;
    }

    public string Text { get; private set; }
    public string VariableName => variables.FirstOrDefault()?.Name ?? "x";
    public string? Name { get; private set; }
    public IReadOnlyList<Variable> Variables => variables.AsReadOnly();

    public static MathExpression Create(string text, string? name = null)
        => new MathExpression(Guid.NewGuid(), text, name);

    public MathExpression WithText(string newText)
    {
        Text = newText;
        variables.Clear();
        return this;
    }

    public MathExpression WithName(string? name)
    {
        Name = name;
        return this;
    }

    public MathExpression AddVariable(Variable variable)
    {
        if (!variables.Any(v => v.Name == variable.Name))
            variables.Add(variable);
        return this;
    }

    public MathExpression RemoveVariable(string name)
    {
        variables.RemoveAll(v => v.Name == name);
        return this;
    }

    public MathExpression ClearVariables()
    {
        variables.Clear();
        return this;
    }

    public Variable GetVariable(string name)
    {
        var variable = variables.FirstOrDefault(v => v.Name == name);

        if (variable == null)
            throw new KeyNotFoundException($"Variable '{name}' not found");

        return variable;
    }
}

==========
File: .\Domain\Entities\PublishedGraph.cs
==========

using GraphCalc.Domain.Common;
using GraphCalc.Domain.ValueObjects;

namespace GraphCalc.Domain.Entities;

public class PublishedGraph : Entity
{
    private PublishedGraph(Guid id, Guid userId, Guid graphId, PublicationMetadata metadata)
        : base(id)
    {
        UserId = userId;
        GraphId = graphId;
        Metadata = metadata;
        IsActive = true;
    }

    public Guid UserId { get; private set; }
    public Guid GraphId { get; private set; }
    public PublicationMetadata Metadata { get; private set; }
    public bool IsActive { get; private set; }

    public static PublishedGraph Create(
        Guid userId,
        Guid graphId,
        string title,
        string? description = null,
        bool isPublic = true)
    {
        return new PublishedGraph(
            Guid.NewGuid(),
            userId,
            graphId,
            PublicationMetadata.Create(title, description, isPublic));
    }

    public void UpdateMetadata(PublicationMetadata newMetadata)
    {
        Metadata = newMetadata ?? throw new ArgumentNullException(nameof(newMetadata));
    }
}


==========
File: .\Domain\Entities\User.cs
==========

using GraphCalc.Domain.Common;

namespace GraphCalc.Domain.Entities;

public class User : Entity
{
    private readonly List<Guid> publishedGraphIds = new();

    private User(Guid id, string username, string email, string? description = null)
        : base(id)
    {
        Username = username;
        Email = email;
        Description = description;
    }

    public string Username { get; private set; }
    public string Email { get; private set; }
    public string? Description { get; private set; }
    public IReadOnlyList<Guid> PublishedGraphIds => publishedGraphIds.AsReadOnly();

    public static User Create(string username, string email, string? description = null)
    {
        if (string.IsNullOrWhiteSpace(username))
            throw new ArgumentException("Username не может быть пустым", nameof(username));

        if (string.IsNullOrWhiteSpace(email))
            throw new ArgumentException("Email не может быть пустым", nameof(email));

        return new User(
            Guid.NewGuid(),
            username,
            email,
            description);
    }

    public void UpdateDescription(string? description)
    {
        Description = description;
    }

    public void PublishGraph(Guid graphId)
    {
        if (!publishedGraphIds.Contains(graphId))
            publishedGraphIds.Add(graphId);
    }

    public void UnpublishGraph(Guid graphId) => publishedGraphIds.Remove(graphId);

    public void ClearPublishedGraphs() => publishedGraphIds.Clear();
}


==========
File: .\Domain\Entities\Variable.cs
==========

using GraphCalc.Domain.Common;

namespace GraphCalc.Domain.Entities;

public class Variable : Entity
{
    private Variable(Guid id, string name, double defaultValue = 0)
        : base(id)
    {
        Name = name;
        DefaultValue = defaultValue;
        CurrentValue = defaultValue;
    }

    public string Name { get; private init; }
    public double DefaultValue { get; private set; }
    public double CurrentValue { get; private set; }

    public static Variable Create(string name, double defaultValue = 0)
        => new Variable(Guid.NewGuid(), name, defaultValue);

    public Variable SetValue(double value)
    {
        if (!double.IsNaN(value) && !double.IsInfinity(value))
            CurrentValue = value;
        return this;
    }

    public Variable SetDefaultValue(double value)
    {
        if (!double.IsNaN(value) && !double.IsInfinity(value))
            DefaultValue = value;
        return this;
    }

    public Variable Reset()
    {
        CurrentValue = DefaultValue;
        return this;
    }
}

==========
File: .\Domain\Interfaces\IExpressionEvaluator.cs
==========

using GraphCalc.Domain.Entities;

namespace GraphCalc.Domain.Interfaces;

public interface IExpressionEvaluator
{
    double Evaluate(MathExpression expression, double variableValue);
    IEnumerable<double> EvaluateBatch(MathExpression expression, IEnumerable<double> variableValues);
}


==========
File: .\Domain\Interfaces\IGraphCalculator.cs
==========

using GraphCalc.Domain.Entities;
using GraphCalc.Domain.ValueObjects;

namespace GraphCalc.Domain.Interfaces;

public interface IGraphCalculator
{
    IEnumerable<MathPoint> Calculate(Graph graph);
    IEnumerable<MathPoint> FindRoots(Graph graph, double precision = 0.001);
    IEnumerable<MathPoint> FindExtrema(Graph graph, double precision = 0.001);
}


==========
File: .\Domain\Interfaces\IGraphRepository.cs
==========

using GraphCalc.Domain.Entities;

namespace GraphCalc.Domain.Interfaces;

public interface IGraphRepository : IRepository<Graph>
{
    IEnumerable<Graph> GetByExpressionText(string expressionText);
}

==========
File: .\Domain\Interfaces\IRepository.cs
==========

using GraphCalc.Domain.Common;

namespace GraphCalc.Domain.Interfaces;

public interface IRepository<T> where T : Entity
{
    T? GetById(Guid id);
    IReadOnlyList<T> GetAll();
    bool Add(T entity);
    bool Update(T entity);
    bool Delete(Guid id);
}

==========
File: .\Domain\Interfaces\IUserRepository.cs
==========

using GraphCalc.Domain.Entities;

namespace GraphCalc.Domain.Interfaces;

public interface IUserRepository : IRepository<User>
{
    User? GetByEmail(string email);
    User? GetByUsername(string username);
}

==========
File: .\Domain\ValueObjects\MathPoint.cs
==========

namespace GraphCalc.Domain.ValueObjects;

public readonly record struct MathPoint(double X, double Y)
{
    public System.Drawing.PointF ToPointF() => new((float)X, (float)Y);
    public System.Drawing.Point ToPoint() => new((int)Math.Round(X), (int)Math.Round(Y));
    public override string ToString() => $"({X:F2}, {Y:F2})";
}


==========
File: .\Domain\ValueObjects\NumericRange.cs
==========

namespace GraphCalc.Domain.ValueObjects;

public sealed record NumericRange
{
    public double Min { get; }
    public double Max { get; }
    public double Step { get; }

    private NumericRange(double min, double max, double step)
    {
        Min = min;
        Max = max;
        Step = step;
    }

    public static NumericRange Create(double min, double max, double? step = null)
    {
        if (double.IsNaN(min) || double.IsInfinity(min))
            throw new ArgumentException("Min must be a valid finite number");

        if (double.IsNaN(max) || double.IsInfinity(max))
            throw new ArgumentException("Max must be a valid finite number");

        if (min >= max)
            throw new ArgumentException("Min must be less than Max");

        var calculatedStep = step ?? (max - min) / 1000;

        return new NumericRange(min, max, calculatedStep);
    }

    public IEnumerable<double> GetValues()
    {
        for (double value = Min; value <= Max; value += Step)
            yield return value;
    }

    public int PointCount => (int)Math.Floor((Max - Min) / Step) + 1;

    public NumericRange WithMin(double min) => Create(min, Max, Step);
    public NumericRange WithMax(double max) => Create(Min, max, Step);
    public NumericRange WithStep(double step) => Create(Min, Max, step);
}

==========
File: .\Domain\ValueObjects\PublicationMetadata.cs
==========

using GraphCalc.Domain.Common;

namespace GraphCalc.Domain.ValueObjects;

public record PublicationMetadata : ValueObject
{
    public required string Title { get; init; }
    public string? Description { get; init; }
    public bool IsPublic { get; init; }

    public PublicationMetadata() { }

    public PublicationMetadata(
        string title,
        string? description = null,
        bool isPublic = true)
    {
        Title = title;
        Description = description;
        IsPublic = isPublic;
    }

    public static PublicationMetadata Create(
        string title,
        string? description = null,
        bool isPublic = true)
    {
        return new()
        {
            Title = title,
            Description = description,
            IsPublic = isPublic,
        };
    }
}


==========
File: .\Infrastructure\ExpressionEvaluator\CodingSebExpressionEvaluator.cs
==========

using GraphCalc.Domain.Interfaces;
using CodingSeb.ExpressionEvaluator;
using GraphCalc.Domain.Entities;

namespace GraphCalc.Infrastructure.ExpressionEvaluation;

/// <summary>
/// Implement IExpressionEvaluator on CodingSeb.ExpressionEvaluator
/// https://github.com/codingseb/ExpressionEvaluator
/// </summary>
public sealed class CodingSebExpressionEvaluator : IExpressionEvaluator
{
    private readonly ExpressionEvaluator evaluator;
    private readonly object locker = new();

    public CodingSebExpressionEvaluator()
    {
        evaluator = new ExpressionEvaluator
        {
            OptionCaseSensitiveEvaluationActive = false,
            OptionForceIntegerNumbersEvaluationsAsDoubleByDefault = true
        };

        ConfigureMathFunctions();
    }

    private void ConfigureMathFunctions()
    {
        evaluator.Variables["pi"] = Math.PI;
        evaluator.Variables["e"] = Math.E;
    }

    public double Evaluate(MathExpression expression, double variableValue)
    {
        lock (locker)
        {
            evaluator.Variables[expression.VariableName] = variableValue;
            var result = evaluator.Evaluate(expression.Text);
            var doubleResult = Convert.ToDouble(result);
            return doubleResult;
        }
    }

    public IEnumerable<double> EvaluateBatch(MathExpression expression, IEnumerable<double> variableValues)
    {
        var results = new List<double>();

        foreach (var value in variableValues)
        {
            var result = Evaluate(expression, value);
            results.Add(result);
        }

        return results;
    }
}


==========
File: .\Infrastructure\Facade\GraphCalculationFacade.cs
==========

using GraphCalc.Domain.Entities;
using GraphCalc.Domain.ValueObjects;
using GraphCalc.Domain.Interfaces;
using GraphCalc.Infrastructure.ExpressionEvaluation;
using GraphCalc.Infrastructure.GraphCalculation;

namespace GraphCalc.Infrastructure.Facade;

public class GraphCalculationFacade
{
    private readonly IExpressionEvaluator evaluator;

    public GraphCalculationFacade(IExpressionEvaluator? evaluator = null)
    {
        this.evaluator = evaluator ?? new CodingSebExpressionEvaluator();
    }

    public Graph GetGraph(
        string expression,
        double xMin,
        double xMax,
        double xStep)
    {
        var mathExpr = MathExpression.Create(expression);
        var graph = Graph.Create(mathExpr, "x");
        var xRange = NumericRange.Create(xMin, xMax, xStep);
        graph.WithRange(xRange);

        var calculator = new NumericalGraphCalculator(evaluator);
        var mathPoints = calculator.Calculate(graph).ToList();
        graph.SetPoints(mathPoints);

        return graph;
    }

    public Graph GetGraphWithAutoYRange(
        string expression,
        double xMin,
        double xMax,
        double xStep)
    {
        var mathExpr = MathExpression.Create(expression);
        var graph = Graph.Create(mathExpr, "x");
        var xRange = NumericRange.Create(xMin, xMax, xStep);
        graph.WithRange(xRange);

        var calculator = new NumericalGraphCalculator(evaluator);
        var mathPoints = calculator.Calculate(graph).ToList();
        graph.SetPoints(mathPoints);

        var yValues = mathPoints.Where(p => !double.IsNaN(p.Y) && !double.IsInfinity(p.Y)).Select(p => p.Y);
        var yMin = yValues.Any() ? yValues.Min() : -1;
        var yMax = yValues.Any() ? yValues.Max() : 1;
        var padding = (yMax - yMin) * 0.1;
        
        var yRange = NumericRange.Create(yMin - padding, yMax + padding, 0.1);
        graph.WithRange(yRange);

        return graph;
    }
}


==========
File: .\Infrastructure\GraphCalculator\NumericalGraphCalculator.cs
==========

using GraphCalc.Domain.Entities;
using GraphCalc.Domain.Interfaces;
using GraphCalc.Domain.ValueObjects;

namespace GraphCalc.Infrastructure.GraphCalculation;

public sealed class NumericalGraphCalculator : IGraphCalculator
{
    private const int MaxIterations = 64;
    private readonly IExpressionEvaluator evaluator;

    public NumericalGraphCalculator(IExpressionEvaluator evaluator)
    {
        this.evaluator = evaluator ?? throw new ArgumentNullException(nameof(evaluator));
    }

    public IEnumerable<MathPoint> Calculate(Graph graph)
    {
        var samples = SampleGraph(graph);

        foreach (var sample in samples)
        {
            if (!sample.isValid)
                continue;

            yield return new MathPoint(sample.x, sample.y);
        }
    }

    public IEnumerable<MathPoint> FindRoots(Graph graph, double precision = 0.001)
    {
        var samples = SampleGraph(graph).Where(p => p.isValid).ToList();

        if (samples.Count < 2)
            yield break;

        for (int i = 0; i < samples.Count - 1; i++)
        {
            var current = samples[i];
            var next = samples[i + 1];

            if (Math.Abs(current.y) <= precision)
            {
                yield return new MathPoint(current.x, 0);
                continue;
            }

            if (current.y * next.y > 0)
                continue;

            var root = RefineRoot(graph, current.x, next.x, precision);

            if (!double.IsNaN(root))
            {
                yield return new MathPoint(root, 0);
            }
        }
    }

    public IEnumerable<MathPoint> FindExtrema(Graph graph, double precision = 0.001)
    {
        var samples = SampleGraph(graph).Where(p => p.isValid).ToList();

        if (samples.Count < 3)
            yield break;

        for (int i = 1; i < samples.Count - 1; i++)
        {
            var prev = samples[i - 1];
            var current = samples[i];
            var next = samples[i + 1];

            double slopeLeft = (current.y - prev.y) / (current.x - prev.x);
            double slopeRight = (next.y - current.y) / (next.x - current.x);

            if (double.IsNaN(slopeLeft) || double.IsNaN(slopeRight))
                continue;

            if (Math.Abs(slopeLeft) <= precision && Math.Abs(slopeRight) <= precision)
            {
                yield return new MathPoint(current.x, current.y);
                continue;
            }

            if (slopeLeft < 0 && slopeRight > 0 ||
                slopeLeft > 0 && slopeRight < 0)
            {
                var extremumX = RefineExtremum(graph, prev.x, current.x, next.x, precision);

                if (double.IsNaN(extremumX))
                    extremumX = current.x;

                var extremumY = EvaluateSafe(graph, extremumX);

                if (double.IsNaN(extremumY))
                    continue;

                yield return new MathPoint(extremumX, extremumY);
            }
        }
    }

    private List<(double x, double y, bool isValid)> SampleGraph(Graph graph)
    {
        if (graph == null)
            throw new ArgumentNullException(nameof(graph));

        if (graph.Range == null)
            throw new ArgumentException("Graph range must be specified.", nameof(graph));

        var samples = new List<(double x, double y, bool isValid)>();

        foreach (var x in graph.Range.GetValues())
        {
            var y = EvaluateSafe(graph, x);
            samples.Add((x, y, !double.IsNaN(y) && !double.IsInfinity(y)));
        }

        return samples;
    }

    private double RefineRoot(Graph graph, double left, double right, double precision)
    {
        double fLeft = EvaluateSafe(graph, left);
        double fRight = EvaluateSafe(graph, right);

        if (double.IsNaN(fLeft) || double.IsNaN(fRight) || Math.Sign(fLeft) == Math.Sign(fRight))
            return double.NaN;

        for (int i = 0; i < MaxIterations; i++)
        {
            double mid = (left + right) / 2;
            double fMid = EvaluateSafe(graph, mid);

            if (double.IsNaN(fMid))
                return double.NaN;

            if (Math.Abs(fMid) <= precision || Math.Abs(right - left) / 2 <= precision)
                return mid;

            if (Math.Sign(fLeft) == Math.Sign(fMid))
            {
                left = mid;
                fLeft = fMid;
            }
            else
            {
                right = mid;
                fRight = fMid;
            }
        }

        return (left + right) / 2;
    }

    private double RefineExtremum(Graph graph, double left, double middle, double right, double precision)
    {
        double EvaluateDerivative(double x)
        {
            double step = Math.Max(precision, Math.Abs(right - left) / 100);
            double forward = EvaluateSafe(graph, x + step);
            double backward = EvaluateSafe(graph, x - step);

            if (double.IsNaN(forward) || double.IsNaN(backward))
                return double.NaN;

            return (forward - backward) / (2 * step);
        }

        double dLeft = EvaluateDerivative(left);
        double dMiddle = EvaluateDerivative(middle);
        double dRight = EvaluateDerivative(right);

        if (double.IsNaN(dLeft) || double.IsNaN(dRight))
            return double.NaN;

        double a = left;
        double b = right;
        double da = dLeft;
        double db = dRight;

        if (Math.Sign(da) == Math.Sign(db))
            return double.NaN;

        for (int i = 0; i < MaxIterations; i++)
        {
            double mid = (a + b) / 2;
            double dMid = EvaluateDerivative(mid);

            if (double.IsNaN(dMid))
                return double.NaN;

            if (Math.Abs(dMid) <= precision || Math.Abs(b - a) / 2 <= precision)
                return mid;

            if (Math.Sign(da) == Math.Sign(dMid))
            {
                a = mid;
                da = dMid;
            }
            else
            {
                b = mid;
                db = dMid;
            }
        }

        return (a + b) / 2;
    }

    private double EvaluateSafe(Graph graph, double x)
    {
        try
        {
            return evaluator.Evaluate(graph.Expression, x);
        }
        catch
        {
            return double.NaN;
        }
    }
}


==========
File: .\Infrastructure\Repositories\InMemoryGraphRepository.cs
==========

using GraphCalc.Domain.Entities;
using GraphCalc.Domain.Interfaces;

namespace GraphCalc.Infrastructure.Persistence;

public class InMemoryGraphRepository : InMemoryRepository<Graph>, IGraphRepository
{
    public IEnumerable<Graph> GetByExpressionText(string expressionText)
    {
        var result = store.Values
            .Where(g => g.Expression.Text.Contains(expressionText, StringComparison.OrdinalIgnoreCase));
        
        return result;
    }
}

==========
File: .\Infrastructure\Repositories\InMemoryGraphSetRepository.cs
==========

using GraphCalc.Domain.Entities;
using GraphCalc.Domain.Interfaces;
using GraphCalc.Infrastructure.Persistence;

namespace GraphCalc.Infrastructure.Repositories;

public class InMemoryGraphSetRepository : InMemoryRepository<GraphSet>
{
}


==========
File: .\Infrastructure\Repositories\InMemoryMathExpressionRepository.cs
==========

using GraphCalc.Domain.Entities;
using GraphCalc.Domain.Interfaces;

namespace GraphCalc.Infrastructure.Persistence;

public class UserInMemoryRepository : InMemoryRepository<User>, IUserRepository
{
    public User? GetByEmail(string email)
    {
        var user = store.Values.FirstOrDefault(u => u.Email.Equals(email, StringComparison.OrdinalIgnoreCase));
        return user;
    }

    public User? GetByUsername(string username)
    {
        var user = store.Values.FirstOrDefault(u => u.Username.Equals(username, StringComparison.OrdinalIgnoreCase));
        return user;
    }
}

==========
File: .\Infrastructure\Repositories\InMemoryPublishedGraphRepository.cs
==========

using GraphCalc.Domain.Entities;
using GraphCalc.Domain.Interfaces;
using GraphCalc.Infrastructure.Persistence;

namespace GraphCalc.Infrastructure.Repositories;

public class InMemoryPublishedGraphRepository : InMemoryRepository<PublishedGraph>
{
    public IReadOnlyList<PublishedGraph> GetByUserId(Guid userId)
        => GetAll()
            .Where(pg => pg.UserId == userId && pg.IsActive)
            .ToList()
            .AsReadOnly();

    public IReadOnlyList<PublishedGraph> GetByGraphId(Guid graphId)
        => GetAll()
            .Where(pg => pg.GraphId == graphId && pg.IsActive)
            .ToList()
            .AsReadOnly();
}


==========
File: .\Infrastructure\Repositories\InMemoryRepository.cs
==========

using GraphCalc.Domain.Common;
using GraphCalc.Domain.Interfaces;

namespace GraphCalc.Infrastructure.Persistence;

public abstract class InMemoryRepository<T> : IRepository<T> where T : Entity
{
    protected readonly Dictionary<Guid, T> store = new();

    public T? GetById(Guid id)
    {
        store.TryGetValue(id, out var entity);
        return entity;
    }

    public IReadOnlyList<T> GetAll()
    {
        var all = store.Values.ToList().AsReadOnly();
        return all;
    }

    public bool Add(T entity)
    {
        if (store.ContainsKey(entity.Id))
            throw new InvalidOperationException($"Entity with ID {entity.Id} already exists.");
        
        store[entity.Id] = entity;
        return true;
    }

    public bool Update(T entity)
    {
        if (!store.ContainsKey(entity.Id))
            throw new KeyNotFoundException($"Entity with ID {entity.Id} not found.");

        store[entity.Id] = entity;
        return true;
    }

    public bool Delete(Guid id) => store.Remove(id);
}

==========
File: .\Infrastructure\Repositories\InMemoryUserRepository.cs
==========

using GraphCalc.Domain.Entities;
using GraphCalc.Domain.Interfaces;
using GraphCalc.Infrastructure.Persistence;

namespace GraphCalc.Infrastructure.Repositories;

public class InMemoryUserRepository : InMemoryRepository<User>, IUserRepository
{
    public User? GetByEmail(string email) 
        => GetAll().FirstOrDefault(u => u.Email == email);

    public User? GetByUsername(string username) 
        => GetAll().FirstOrDefault(u => u.Username == username);
}


==========
File: .\Presentation\Coordinates\ICoordinateTransformer.cs
==========

using System.Drawing;
using GraphCalc.Domain.ValueObjects;

namespace GraphCalc.Presentation.Coordinates;

public interface ICoordinateTransformer
{
    PointF WorldToScreen(MathPoint worldPoint, NumericRange xRange, NumericRange yRange, Size screenSize);

    MathPoint ScreenToWorld(PointF screenPoint, NumericRange xRange, NumericRange yRange, Size screenSize);
}


==========
File: .\Presentation\Coordinates\SimpleCoordinateTransformer.cs
==========

using System.Drawing;
using GraphCalc.Domain.ValueObjects;

namespace GraphCalc.Presentation.Coordinates;

public class SimpleCoordinateTransformer : ICoordinateTransformer
{
    public PointF WorldToScreen(MathPoint worldPoint, NumericRange xRange, NumericRange yRange, Size screenSize)
    {
        if (xRange == null) throw new ArgumentNullException(nameof(xRange));
        if (yRange == null) throw new ArgumentNullException(nameof(yRange));
        if (screenSize.Width <= 0 || screenSize.Height <= 0)
            throw new ArgumentException("Screen size must be positive", nameof(screenSize));

        var xSpan = xRange.Max - xRange.Min;
        var ySpan = yRange.Max - yRange.Min;

        if (xSpan == 0 || ySpan == 0)
            return new PointF(screenSize.Width / 2f, screenSize.Height / 2f);

        var normalizedX = (worldPoint.X - xRange.Min) / xSpan;
        var normalizedY = (yRange.Max - worldPoint.Y) / ySpan; // Y is inverted

        var screenX = (float)(normalizedX * screenSize.Width);
        var screenY = (float)(normalizedY * screenSize.Height);

        return new PointF(screenX, screenY);
    }

    public MathPoint ScreenToWorld(PointF screenPoint, NumericRange xRange, NumericRange yRange, Size screenSize)
    {
        if (xRange == null) throw new ArgumentNullException(nameof(xRange));
        if (yRange == null) throw new ArgumentNullException(nameof(yRange));
        if (screenSize.Width <= 0 || screenSize.Height <= 0)
            throw new ArgumentException("Screen size must be positive", nameof(screenSize));

        var xSpan = xRange.Max - xRange.Min;
        var ySpan = yRange.Max - yRange.Min;

        if (xSpan == 0 || ySpan == 0)
            return new MathPoint((xRange.Min + xRange.Max) / 2, (yRange.Min + yRange.Max) / 2);

        var normalizedX = screenPoint.X / screenSize.Width;
        var normalizedY = screenPoint.Y / screenSize.Height;

        var worldX = xRange.Min + normalizedX * xSpan;
        var worldY = yRange.Max - normalizedY * ySpan; // Y is inverted

        return new MathPoint(worldX, worldY);
    }
}


==========
File: .\Presentation\Facades\GraphDisplayFacade.cs
==========

using System.Drawing;
using GraphCalc.Domain.Entities;
using GraphCalc.Domain.ValueObjects;
using GraphCalc.Presentation.Coordinates;
using GraphCalc.Presentation.Mappers;
using GraphCalc.Presentation.Models;

namespace GraphCalc.Presentation.Facades;

public class GraphDisplayFacade
{
    private readonly ICoordinateTransformer transformer;

    public GraphDisplayFacade(ICoordinateTransformer? transformer = null)
    {
        this.transformer = transformer ?? new SimpleCoordinateTransformer();
    }

    public RenderableGraph Display(
        Graph graph,
        double yMin,
        double yMax,
        Size screenSize)
    {
        if (graph.Range == null)
            throw new InvalidOperationException("Graph must have a range set before display");

        var xRange = graph.Range;
        var yRange = NumericRange.Create(yMin, yMax, 0.1);

        return GraphToRenderableGraphMapper.Map(
            graph,
            transformer,
            xRange,
            yRange,
            screenSize);
    }

    public RenderableGraph DisplayWithAutoYRange(
        Graph graph,
        Size screenSize)
    {
        if (graph.Range == null)
            throw new InvalidOperationException("Graph must have a range set before display");

        var xRange = graph.Range;
        
        // Calculate Y range from points
        var yValues = graph.Points
            .Where(p => !double.IsNaN(p.Y) && !double.IsInfinity(p.Y))
            .Select(p => p.Y);

        var yMin = yValues.Any() ? yValues.Min() : -1;
        var yMax = yValues.Any() ? yValues.Max() : 1;
        var padding = (yMax - yMin) * 0.1;
        
        var yRange = NumericRange.Create(yMin - padding, yMax + padding, 0.1);

        return GraphToRenderableGraphMapper.Map(
            graph,
            transformer,
            xRange,
            yRange,
            screenSize);
    }
}


==========
File: .\Presentation\Mappers\GraphCanvasToRenderableGraphCanvasMapper.cs
==========

using GraphCalc.Domain.Entities;
using GraphCalc.Domain.ValueObjects;
using GraphCalc.Presentation.Coordinates;
using GraphCalc.Presentation.Models;
using System.Drawing;

namespace GraphCalc.Presentation.Mappers;

public static class GraphSetToRenderableGraphSetMapper
{
    public static RenderableGraphCanvas Map(
        GraphSet graphCanvas,
        ICoordinateTransformer transformer,
        NumericRange xRange,
        NumericRange yRange,
        Size screenSize)
    {
        var renderableGraphs = GraphToRenderableGraphMapper.MapMany(
            graphCanvas.Graphs,
            transformer,
            xRange,
            yRange,
            screenSize);

        return new RenderableGraphCanvas
        {
            Id = graphCanvas.Id,
            Graphs = renderableGraphs.ToList(),
            CanvasSize = screenSize
        };
    }
}

==========
File: .\Presentation\Mappers\GraphToRenderableGraphMapper.cs
==========

using System.Drawing;
using GraphCalc.Domain.Entities;
using GraphCalc.Domain.ValueObjects;
using GraphCalc.Presentation.Coordinates;
using GraphCalc.Presentation.Models;

namespace GraphCalc.Presentation.Mappers;

public static class GraphToRenderableGraphMapper
{
    public static RenderableGraph Map(
        Graph graph,
        ICoordinateTransformer transformer,
        NumericRange xRange,
        NumericRange yRange,
        Size screenSize)
    {
        var screenPoints = graph.Points
            .Select(p => transformer.WorldToScreen(p, xRange, yRange, screenSize))
            .ToArray();

        var style = GraphStyle.Default;

        return new RenderableGraph
        {
            Id = graph.Id,
            Label = graph.IndependentVariable,
            ScreenPoints = screenPoints,
            IsVisible = true,
            StrokeColor = style.Color,
            StrokeWidth = (float)style.LineThickness,
            LineStyle = style.LineStyle,
            ShowPoints = style.ShowPoints,
            PointSize = (float)style.PointSize
        };
    }

    public static IEnumerable<RenderableGraph> MapMany(
        IEnumerable<Graph> graphs,
        ICoordinateTransformer transformer,
        NumericRange xRange,
        NumericRange yRange,
        Size screenSize)
        => graphs.Select(g => Map(g, transformer, xRange, yRange, screenSize));
}


==========
File: .\Presentation\Models\GraphStyle.cs
==========

using System.Drawing;

namespace GraphCalc.Presentation.Models;

public record GraphStyle
{
    public Color Color { get; init; }
    public double LineThickness { get; init; }
    public LineStyle LineStyle { get; init; }
    public bool ShowPoints { get; init; }
    public double PointSize { get; init; }

    private GraphStyle(
        Color color,
        double lineThickness = 2.0,
        LineStyle lineStyle = LineStyle.Solid,
        bool showPoints = false,
        double pointSize = 3.0)
    {
        Color = color;
        LineThickness = lineThickness;
        LineStyle = lineStyle;
        ShowPoints = showPoints;
        PointSize = pointSize;
    }

    public static GraphStyle Create(
        Color color,
        double lineThickness = 2.0,
        LineStyle lineStyle = LineStyle.Solid,
        bool showPoints = false,
        double pointSize = 3.0)
    {
        if (lineThickness <= 0 || lineThickness > 10)
            throw new ArgumentException("Line thickness must be between 0 and 10");

        if (pointSize <= 0 || pointSize > 20)
            throw new ArgumentException("Point size must be between 0 and 20");

        return new GraphStyle(color, lineThickness, lineStyle, showPoints, pointSize);
    }

    public GraphStyle WithColor(Color color) 
        => this with { Color = color };

    public GraphStyle WithThickness(double thickness) 
        => Create(Color, thickness, LineStyle, ShowPoints, PointSize);

    public GraphStyle WithLineStyle(LineStyle style) 
        => this with { LineStyle = style };

    public GraphStyle WithPoints(bool show, double size = 3.0) 
        => Create(Color, LineThickness, LineStyle, show, size);

    public static readonly GraphStyle Default = new(
        Color.Blue,
        lineThickness: 2.0,
        lineStyle: LineStyle.Solid,
        showPoints: false,
        pointSize: 3.0);
}

==========
File: .\Presentation\Models\LineStyle.cs
==========

namespace GraphCalc.Presentation.Models;

public enum LineStyle
{
    Solid,
    Dashed,
    Dotted,
    DashDot
}


==========
File: .\Presentation\Models\RenderableGraph.cs
==========

using System.Drawing;

namespace GraphCalc.Presentation.Models;

public class RenderableGraph
{
    public Guid Id { get; init; }
    public string Label { get; init; } = string.Empty;
    public IReadOnlyList<PointF> ScreenPoints { get; init; } = Array.Empty<PointF>();
    public bool IsVisible { get; init; } = true;
    public Color StrokeColor { get; init; } = Color.Black;
    public float StrokeWidth { get; init; } = 1f;
    public LineStyle LineStyle { get; init; } = LineStyle.Solid;
    public bool ShowPoints { get; init; } = false;
    public float PointSize { get; init; } = 3f;
    public int ZIndex { get; init; } = 0;

    public override string ToString() => $"RenderableGraph({Label}, {ScreenPoints.Count} points)";
}


==========
File: .\Presentation\Models\RenderableGraphSet.cs
==========

using System.Drawing;

namespace GraphCalc.Presentation.Models;

public class RenderableGraphCanvas
{
    public Guid Id { get; init; }
    public List<RenderableGraph> Graphs { get; init; } = new();
    public bool ShowLegend { get; init; } = true;
    public Size CanvasSize { get; set; }
}
